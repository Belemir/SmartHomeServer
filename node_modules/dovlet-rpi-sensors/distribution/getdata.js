'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//Importing Dependencies
var gpio = require('rpi-gpio');
var EventEmitter = require('events').EventEmitter;
var omapper = require('o-mapper');

//Defining SCHEMA

var OPTIONS_SCHEMA = {
    pinNumber: {
        required: true
    },
    loopInterval: {
        default: 1000
    }

    //Sensor Class
};
var Sensor = function (_EventEmitter) {
    _inherits(Sensor, _EventEmitter);

    function Sensor(options, pinNumber, loopInterval, detection, lastDetectionTime, interval) {
        _classCallCheck(this, Sensor);

        var _this = _possibleConstructorReturn(this, (Sensor.__proto__ || Object.getPrototypeOf(Sensor)).call(this));

        _this.options = omapper(options, OPTIONS_SCHEMA);
        _this.pinNumber = options.pinNumber;
        _this.loopInterval = options.loopInterval;
        _this.detection = false;
        _this.lastDetectionTime = undefined;
        _this.interval = undefined;

        //Sensor:Read Sensor through GPIO
        _this.readSensor = function () {
            gpio.read(_this.pinNumber, function (err, val) {

                if (val === _this.detection) {
                    return;
                }

                _this.detection = val;

                if (_this.detection) {
                    _this.lastDetectionTime = new Date();
                    _this.emit('detection');
                }
            });
        };

        //Sensor: Callback function for Start Detection
        _this.startSensorDetection = function () {

            _this.interval = setInterval(_this.readSensor, _this.loopInterval);

            return _this.interval;
        };

        //Sensor: Start Detection
        _this.startDetection = function () {
            gpio.setMode(gpio.MODE_BCM);
            gpio.setup(_this.pinNumber, gpio.DIR_IN, _this.startSensorDetection);
        };

        //Sensor: Stop Detection
        _this.stopDetection = function () {
            if (!_this.interval) {
                return false;
            }

            clearInterval(_this.interval);
            _this.interval = undefined;

            return true;
        };

        //Sensor: Set HIGH => GPIO
        _this.setHighPin = function () {
            gpio.setMode(gpio.MODE_BCM);
            gpio.setup(_this.pinNumber, gpio.DIR_HIGH, _this.setHighGpio);
        };

        //Sensor: Callback function for setHighPin
        _this.setHighGpio = function () {
            gpio.write(_this.pinNumber, true, function (err) {
                if (err) throw err;
            });
        };

        //Sensor: Set LOW => GPIO
        _this.setLowPin = function () {
            gpio.setMode(gpio.MODE_BCM);
            gpio.setup(_this.pinNumber, gpio.DIR_LOW, _this.setLowGpio);
        };

        //Sensor: Callback function for setLowPin
        _this.setLowGpio = function () {
            gpio.write(_this.pinNumber, true, function (err) {
                if (err) throw err;
            });
        };
        return _this;
    }

    return Sensor;
}(EventEmitter);

module.exports = Sensor;